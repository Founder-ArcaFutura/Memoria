#!/usr/bin/env python3
"""Helpers for bootstrapping and running the local Docker stack."""

from __future__ import annotations

import argparse
import json
import os
import secrets
import shutil
import subprocess
import sys
import textwrap
import time
import urllib.error
import urllib.request
from datetime import datetime
from pathlib import Path
from typing import Dict, Iterable, Tuple

ROOT = Path(__file__).resolve().parents[1]
ENV_PATH = ROOT / ".env"
CONFIG_PATH = ROOT / "memoria.json"
DEFAULT_SQLITE_PATH = "/workspace/sqlite/memoria.db"
DEFAULT_CONFIG = {
    "enable_heuristic_clustering": True,
    "enable_vector_clustering": False,
    "enable_cluster_indexing": True,
    "database": {
        "connection_string": f"sqlite:///{DEFAULT_SQLITE_PATH}",
        "pool_size": 5,
        "echo_sql": False,
        "backup_enabled": False,
        "backup_interval_hours": 24,
    },
}


def _load_env_values(path: Path) -> Dict[str, str]:
    values: Dict[str, str] = {}
    if not path.exists():
        return values

    for line in path.read_text().splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            continue
        if "=" not in stripped:
            continue
        key, value = stripped.split("=", 1)
        values[key.strip()] = value.strip()
    return values


def _write_env_template(path: Path) -> None:
    password = secrets.token_urlsafe(18)
    memoria_api_key = secrets.token_urlsafe(32)
    flask_secret = secrets.token_hex(32)
    ui_secret = secrets.token_hex(32)
    timestamp = datetime.utcnow().isoformat(timespec="seconds") + "Z"

    template = textwrap.dedent(
        f"""
        # Local development defaults generated by scripts/run_local.py on {timestamp}
        POSTGRES_USER=memoria
        POSTGRES_PASSWORD={password}
        POSTGRES_DB=memoria
        DATABASE_URL=postgresql://memoria:{password}@db:5432/memoria
        MEMORIA_API_KEY={memoria_api_key}
        FLASK_SECRET_KEY={flask_secret}
        MEMORIA_UI_SESSION_SECRET={ui_secret}
        OPENAI_API_KEY=
        # To use the optional SQLite volume instead of Postgres, switch to:
        # DATABASE_URL=sqlite:////workspace/sqlite/memoria.db
        """
    ).strip()

    path.write_text(template + "\n")


def _append_missing_env_values(path: Path, existing: Dict[str, str]) -> bool:
    changed = False
    missing: list[Tuple[str, str]] = []

    def ensure(key: str, factory) -> None:
        nonlocal changed
        if existing.get(key):
            return
        value = factory() if callable(factory) else factory
        existing[key] = value
        missing.append((key, value))
        changed = True

    ensure("POSTGRES_USER", "memoria")
    ensure("POSTGRES_DB", "memoria")
    ensure("POSTGRES_PASSWORD", lambda: secrets.token_urlsafe(18))
    ensure(
        "DATABASE_URL",
        lambda: f"postgresql://{existing['POSTGRES_USER']}:{existing['POSTGRES_PASSWORD']}@db:5432/{existing['POSTGRES_DB']}",
    )
    ensure("MEMORIA_API_KEY", lambda: secrets.token_urlsafe(32))
    ensure("FLASK_SECRET_KEY", lambda: secrets.token_hex(32))
    ensure("MEMORIA_UI_SESSION_SECRET", lambda: secrets.token_hex(32))

    if not changed:
        return False

    header = textwrap.dedent(
        f"""
        \n# Missing values added by scripts/run_local.py on {datetime.utcnow().isoformat(timespec='seconds')}Z
        """
    )

    with path.open("a", encoding="utf-8") as handle:
        handle.write(header)
        for key, value in missing:
            handle.write(f"{key}={value}\n")

    return True


def ensure_env_file(force: bool = False) -> bool:
    if force or not ENV_PATH.exists():
        _write_env_template(ENV_PATH)
        return True

    existing = _load_env_values(ENV_PATH)
    return _append_missing_env_values(ENV_PATH, existing)


def ensure_config_file() -> bool:
    if CONFIG_PATH.exists():
        return False
    CONFIG_PATH.write_text(json.dumps(DEFAULT_CONFIG, indent=2) + "\n", encoding="utf-8")
    return True


def bootstrap(force_env: bool = False) -> bool:
    changed = ensure_env_file(force=force_env)
    changed |= ensure_config_file()
    return changed


def _require_docker() -> None:
    if shutil.which("docker") is None:
        raise SystemExit("Docker is required to run this command but was not found in PATH.")


def run_compose(*args: str, check: bool = True) -> subprocess.CompletedProcess[str]:
    _require_docker()
    cmd = ["docker", "compose", *args]
    return subprocess.run(cmd, cwd=ROOT, check=check, text=True)


def wait_for_http(url: str, headers: Dict[str, str], timeout: float) -> int:
    deadline = time.monotonic() + timeout
    last_error: Exception | None = None

    while time.monotonic() < deadline:
        request = urllib.request.Request(url, headers=headers)
        try:
            with urllib.request.urlopen(request, timeout=10) as response:
                status = getattr(response, "status", response.getcode())
                if status < 500:
                    return status
        except urllib.error.HTTPError as exc:  # type: ignore[attr-defined]
            if exc.code < 500:
                return exc.code
            last_error = exc
        except Exception as exc:  # pragma: no cover - network dependent
            last_error = exc

        time.sleep(2)

    if last_error is None:
        raise TimeoutError(f"Service at {url} did not become ready within {timeout} seconds")
    raise TimeoutError(f"Service at {url} did not become ready: {last_error}")


def command_bootstrap(args: argparse.Namespace) -> None:
    changed = bootstrap(force_env=args.force)
    if changed:
        print("✅ Generated local configuration artifacts.")
    else:
        print("ℹ️ Local configuration already satisfied.")


def command_up(args: argparse.Namespace) -> None:
    bootstrap(force_env=False)
    compose_args = ["up"]
    if args.build:
        compose_args.append("--build")
    if args.detach:
        compose_args.append("--detach")
    if args.remove_orphans:
        compose_args.append("--remove-orphans")
    run_compose(*compose_args)


def command_down(args: argparse.Namespace) -> None:
    compose_args = ["down"]
    if args.volumes:
        compose_args.append("--volumes")
    if args.remove_orphans:
        compose_args.append("--remove-orphans")
    run_compose(*compose_args, check=not args.ignore_failures)


def command_reset(args: argparse.Namespace) -> None:
    command_down(argparse.Namespace(volumes=True, remove_orphans=True, ignore_failures=True))
    if args.regenerate_env:
        ensure_env_file(force=True)
        print("🔁 Regenerated .env with fresh secrets.")


def command_smoke(args: argparse.Namespace) -> None:
    bootstrap(force_env=False)
    env_values = _load_env_values(ENV_PATH)
    api_key = env_values.get("MEMORIA_API_KEY", "")

    run_compose("down", "--volumes", "--remove-orphans", check=False)
    try:
        run_compose("up", "--build", "--detach")
        status = wait_for_http(
            url="http://127.0.0.1:8080/settings",
            headers={"X-API-Key": api_key},
            timeout=args.timeout,
        )
        print(f"✅ docker compose stack became healthy (HTTP {status}).")
    except Exception as exc:
        print(f"❌ Docker smoke test failed: {exc}", file=sys.stderr)
        run_compose("logs", "api", check=False)
        raise SystemExit(1) from exc
    finally:
        run_compose("down", "--volumes", "--remove-orphans", check=False)


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description=__doc__)
    subparsers = parser.add_subparsers(dest="command", required=True)

    bootstrap_parser = subparsers.add_parser("bootstrap", help="Create local config files if missing")
    bootstrap_parser.add_argument("--force", action="store_true", help="Regenerate the .env file even if it exists")
    bootstrap_parser.set_defaults(func=command_bootstrap)

    up_parser = subparsers.add_parser("up", help="Bootstrap configs and start docker compose services")
    up_parser.add_argument("--no-build", dest="build", action="store_false", help="Skip rebuilding images")
    up_parser.add_argument("--build", dest="build", action="store_true", default=True, help=argparse.SUPPRESS)
    up_parser.add_argument("--detach", dest="detach", action="store_true", default=True, help=argparse.SUPPRESS)
    up_parser.add_argument("--no-detach", dest="detach", action="store_false", help="Run in the foreground")
    up_parser.add_argument(
        "--remove-orphans",
        action="store_true",
        default=False,
        help="Remove containers for services not defined in the compose file",
    )
    up_parser.set_defaults(func=command_up)

    down_parser = subparsers.add_parser("down", help="Stop docker compose services")
    down_parser.add_argument("--volumes", action="store_true", help="Remove named volumes")
    down_parser.add_argument(
        "--remove-orphans",
        action="store_true",
        default=False,
        help="Remove containers for services not defined in the compose file",
    )
    down_parser.add_argument("--ignore-failures", action="store_true", help="Return success even if docker compose fails")
    down_parser.set_defaults(func=command_down)

    reset_parser = subparsers.add_parser("reset", help="Stop services and remove volumes")
    reset_parser.add_argument(
        "--regenerate-env",
        action="store_true",
        help="Regenerate the .env file with fresh secrets",
    )
    reset_parser.set_defaults(func=command_reset)

    smoke_parser = subparsers.add_parser("smoke", help="Run a docker compose bootstrap smoke test")
    smoke_parser.add_argument(
        "--timeout",
        type=float,
        default=180.0,
        help="Seconds to wait for the API health endpoint",
    )
    smoke_parser.set_defaults(func=command_smoke)

    return parser


def main(argv: Iterable[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    try:
        args.func(args)
    except subprocess.CalledProcessError as exc:  # pragma: no cover - passthrough
        return exc.returncode
    except KeyboardInterrupt:  # pragma: no cover - interactive convenience
        return 130
    return 0


if __name__ == "__main__":
    sys.exit(main())
